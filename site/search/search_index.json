{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"dflockd","text":"<p>A lightweight distributed lock server using a simple line-based TCP protocol with FIFO ordering, automatic lease expiry, and background renewal.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Strict FIFO ordering \u2014 waiters are granted locks in the order they enqueue, per key</li> <li>Automatic lease expiry \u2014 held locks expire if not renewed, preventing deadlocks</li> <li>Background renewal \u2014 both async and sync clients auto-renew leases in the background</li> <li>Disconnect cleanup \u2014 locks are released automatically when a client disconnects</li> <li>Multi-server sharding \u2014 distribute keys across multiple servers with consistent hashing</li> <li>Zero dependencies \u2014 pure Python 3.13+ using only the standard library</li> <li>Simple wire protocol \u2014 line-based UTF-8 over TCP, easy to integrate from any language</li> </ul>"},{"location":"#quick-example","title":"Quick example","text":"<pre><code>from dflockd.sync_client import DistributedLock\n\nwith DistributedLock(\"my-key\", acquire_timeout_s=10) as lock:\n    print(f\"acquired: {lock.token}\")\n    # critical section \u2014 lease auto-renews in background\n</code></pre>"},{"location":"#getting-started","title":"Getting started","text":"<ul> <li>Installation \u2014 install dflockd with pip or uv</li> <li>Quick Start \u2014 run the server and acquire your first lock</li> <li>Examples \u2014 async, sync, FIFO ordering, and multi-server demos</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#030","title":"0.3.0","text":"<ul> <li>Add multi-server sharding with <code>stable_hash_shard</code> (CRC-32)</li> <li>Add custom sharding strategy support</li> <li>Add <code>renew_ratio</code> parameter to control renewal frequency</li> </ul>"},{"location":"changelog/#020","title":"0.2.0","text":"<ul> <li>Add sync client (<code>dflockd.sync_client</code>)</li> <li>Add background lease renewal for both async and sync clients</li> <li>Add <code>DistributedLock</code> context manager interface</li> </ul>"},{"location":"changelog/#010","title":"0.1.0","text":"<ul> <li>Initial release</li> <li>Async lock server with FIFO ordering</li> <li>Automatic lease expiry and garbage collection</li> <li>Disconnect cleanup</li> <li>Async client (<code>dflockd.client</code>)</li> </ul>"},{"location":"api/protocol/","title":"Wire Protocol","text":"<p>dflockd uses a line-based UTF-8 protocol over TCP. Each request is exactly 3 lines: <code>command\\nkey\\narg\\n</code>. Each response is a single line.</p>"},{"location":"api/protocol/#commands","title":"Commands","text":""},{"location":"api/protocol/#lock-acquire","title":"Lock (acquire)","text":"<p>Request a lock on a key with a timeout. Optionally specify a lease TTL.</p> <p>Request: <pre><code>l\n&lt;key&gt;\n&lt;acquire_timeout_s&gt; [&lt;lease_ttl_s&gt;]\n</code></pre></p> <p>Response:</p> <ul> <li>Success: <code>ok &lt;token&gt; &lt;lease_ttl&gt;\\n</code></li> <li>Timeout: <code>timeout\\n</code></li> <li>Max locks reached: <code>error_max_locks\\n</code></li> </ul> <p>Example: <pre><code>l\nmy-job\n10\n</code></pre> \u2192 <code>ok a1b2c3d4e5f6... 33</code></p> <p><pre><code>l\nmy-job\n10 60\n</code></pre> \u2192 <code>ok a1b2c3d4e5f6... 60</code></p>"},{"location":"api/protocol/#release","title":"Release","text":"<p>Release a held lock. The token must match the current owner.</p> <p>Request: <pre><code>r\n&lt;key&gt;\n&lt;token&gt;\n</code></pre></p> <p>Response:</p> <ul> <li>Success: <code>ok\\n</code></li> <li>Token mismatch or unknown key: <code>error\\n</code></li> </ul>"},{"location":"api/protocol/#renew","title":"Renew","text":"<p>Extend the lease on a held lock. Optionally specify a new lease TTL. The lease expiry is reset to <code>now + lease_ttl_s</code>.</p> <p>Request: <pre><code>n\n&lt;key&gt;\n&lt;token&gt; [&lt;lease_ttl_s&gt;]\n</code></pre></p> <p>Response:</p> <ul> <li>Success: <code>ok &lt;seconds_remaining&gt;\\n</code></li> <li>Token mismatch, unknown key, or already expired: <code>error\\n</code></li> </ul> <p>Note</p> <p>A renew request for an already-expired lease will fail. The server does not resurrect expired locks \u2014 the lock transfers to the next waiter on expiry.</p>"},{"location":"api/protocol/#protocol-constraints","title":"Protocol constraints","text":"Constraint Value Max line length 256 bytes Encoding UTF-8 Key Non-empty string (within line limit) Token UUID hex string (32 chars) Timeout Integer &gt;= 0 Lease TTL Integer &gt; 0"},{"location":"api/protocol/#error-codes","title":"Error codes","text":"<p>Protocol violations cause the server to respond with <code>error\\n</code> and close the connection:</p> Code Meaning 3 Invalid command (not <code>l</code>, <code>r</code>, or <code>n</code>) 4 Invalid integer in argument 5 Empty key 6 Negative timeout 7 Empty token 8 Wrong argument count 9 Zero or negative lease TTL 10 Read timeout (no data within server's read timeout) 11 Client disconnected 12 Line too long (exceeds 256 bytes)"},{"location":"api/protocol/#behavior","title":"Behavior","text":"<ul> <li>Locks are granted in strict FIFO order per key.</li> <li>If a lease expires without renewal, the lock automatically passes to the next waiter.</li> <li>When a connection closes, all locks held by that connection are released and transferred to waiters.</li> <li>The server prunes idle lock state (no owner, no waiters) after a configurable idle period.</li> </ul>"},{"location":"api/protocol/#example-session","title":"Example session","text":"<pre><code>\u2192 l\\nmy-key\\n10\\n\n\u2190 ok abc123def456... 33\\n\n\n\u2192 n\\nmy-key\\nabc123def456... \\n\n\u2190 ok 32\\n\n\n\u2192 r\\nmy-key\\nabc123def456...\\n\n\u2190 ok\\n\n</code></pre>"},{"location":"api/protocol/#interoperability","title":"Interoperability","text":"<p>The protocol is language-agnostic. Any TCP client that can send and receive UTF-8 lines can interact with dflockd:</p> <pre><code># netcat example\nprintf 'l\\nmy-key\\n10\\n' | nc localhost 6388\n</code></pre>"},{"location":"api/python/","title":"Python API","text":""},{"location":"api/python/#dflockdclient-async","title":"dflockd.client (async)","text":""},{"location":"api/python/#distributedlock","title":"DistributedLock","text":"<pre><code>@dataclass\nclass DistributedLock:\n    key: str\n    acquire_timeout_s: int = 10\n    lease_ttl_s: int | None = None\n    servers: list[tuple[str, int]] = [(\"127.0.0.1\", 6388)]\n    sharding_strategy: ShardingStrategy = stable_hash_shard\n    renew_ratio: float = 0.5\n</code></pre> <p>Methods:</p> Method Returns Description <code>await acquire()</code> <code>bool</code> Acquire the lock. Returns <code>False</code> on timeout <code>await release()</code> <code>bool</code> Release the lock and stop renewal <code>await aclose()</code> <code>None</code> Close the connection and clean up <p>Context manager:</p> <pre><code>async with DistributedLock(\"key\") as lock:\n    ...  # lock.token, lock.lease available\n</code></pre> <p>Raises <code>TimeoutError</code> if the lock cannot be acquired.</p>"},{"location":"api/python/#low-level-functions","title":"Low-level functions","text":""},{"location":"api/python/#acquire","title":"acquire","text":"<pre><code>async def acquire(\n    reader: asyncio.StreamReader,\n    writer: asyncio.StreamWriter,\n    key: str,\n    acquire_timeout_s: int,\n    lease_ttl_s: int | None = None,\n) -&gt; tuple[str, int]\n</code></pre> <p>Send a lock request. Returns <code>(token, lease_ttl)</code>. Raises <code>TimeoutError</code> on timeout.</p>"},{"location":"api/python/#release","title":"release","text":"<pre><code>async def release(\n    reader: asyncio.StreamReader,\n    writer: asyncio.StreamWriter,\n    key: str,\n    token: str,\n) -&gt; None\n</code></pre> <p>Send a release request. Raises <code>RuntimeError</code> on failure.</p>"},{"location":"api/python/#renew","title":"renew","text":"<pre><code>async def renew(\n    reader: asyncio.StreamReader,\n    writer: asyncio.StreamWriter,\n    key: str,\n    token: str,\n    lease_ttl_s: int | None = None,\n) -&gt; int\n</code></pre> <p>Send a renew request. Returns seconds remaining, or <code>-1</code> if not reported by the server. Raises <code>RuntimeError</code> on failure.</p>"},{"location":"api/python/#dflockdsync_client","title":"dflockd.sync_client","text":""},{"location":"api/python/#distributedlock_1","title":"DistributedLock","text":"<pre><code>@dataclass\nclass DistributedLock:\n    key: str\n    acquire_timeout_s: int = 10\n    lease_ttl_s: int | None = None\n    servers: list[tuple[str, int]] = [(\"127.0.0.1\", 6388)]\n    sharding_strategy: ShardingStrategy = stable_hash_shard\n    renew_ratio: float = 0.5\n</code></pre> <p>Methods:</p> Method Returns Description <code>acquire()</code> <code>bool</code> Acquire the lock. Returns <code>False</code> on timeout <code>release()</code> <code>bool</code> Release the lock and stop renewal <code>close()</code> <code>None</code> Close the connection and clean up <p>Context manager:</p> <pre><code>with DistributedLock(\"key\") as lock:\n    ...  # lock.token, lock.lease available\n</code></pre>"},{"location":"api/python/#low-level-functions_1","title":"Low-level functions","text":""},{"location":"api/python/#acquire_1","title":"acquire","text":"<pre><code>def acquire(\n    sock: socket.socket,\n    rfile: io.TextIOWrapper,\n    key: str,\n    acquire_timeout_s: int,\n    lease_ttl_s: int | None = None,\n) -&gt; tuple[str, int]\n</code></pre>"},{"location":"api/python/#release_1","title":"release","text":"<pre><code>def release(\n    sock: socket.socket,\n    rfile: io.TextIOWrapper,\n    key: str,\n    token: str,\n) -&gt; None\n</code></pre>"},{"location":"api/python/#renew_1","title":"renew","text":"<pre><code>def renew(\n    sock: socket.socket,\n    rfile: io.TextIOWrapper,\n    key: str,\n    token: str,\n    lease_ttl_s: int | None = None,\n) -&gt; int\n</code></pre>"},{"location":"api/python/#dflockdsharding","title":"dflockd.sharding","text":""},{"location":"api/python/#shardingstrategy","title":"ShardingStrategy","text":"<pre><code>ShardingStrategy = Callable[[str, int], int]\n</code></pre> <p>A callable that maps <code>(key, num_servers)</code> to a server index.</p>"},{"location":"api/python/#stable_hash_shard","title":"stable_hash_shard","text":"<pre><code>def stable_hash_shard(key: str, num_servers: int) -&gt; int\n</code></pre> <p>Default sharding strategy using <code>zlib.crc32</code>. Deterministic across processes regardless of <code>PYTHONHASHSEED</code>.</p>"},{"location":"api/python/#default_servers","title":"DEFAULT_SERVERS","text":"<pre><code>DEFAULT_SERVERS: list[tuple[str, int]] = [(\"127.0.0.1\", 6388)]\n</code></pre>"},{"location":"client/async/","title":"Async Client","text":"<p>The async client uses <code>asyncio</code> for non-blocking lock operations with automatic background lease renewal.</p> <pre><code>from dflockd.client import DistributedLock\n</code></pre>"},{"location":"client/async/#context-manager","title":"Context manager","text":"<p>The recommended way to use the client. The lock is acquired on entry and released on exit:</p> <pre><code>import asyncio\nfrom dflockd.client import DistributedLock\n\nasync def main():\n    async with DistributedLock(\"my-key\", acquire_timeout_s=10) as lock:\n        print(f\"token={lock.token} lease={lock.lease}\")\n        # critical section\n\nasyncio.run(main())\n</code></pre> <p>If the lock cannot be acquired within the timeout, a <code>TimeoutError</code> is raised.</p>"},{"location":"client/async/#manual-acquirerelease","title":"Manual acquire/release","text":"<p>For cases where a context manager doesn't fit:</p> <pre><code>lock = DistributedLock(\"my-key\", acquire_timeout_s=10)\nacquired = await lock.acquire()\nif acquired:\n    try:\n        # critical section\n        pass\n    finally:\n        await lock.release()\n</code></pre> <p><code>acquire()</code> returns <code>False</code> on timeout instead of raising.</p>"},{"location":"client/async/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>key</code> <code>str</code> (required) Lock name <code>acquire_timeout_s</code> <code>int</code> <code>10</code> Seconds to wait for acquisition <code>lease_ttl_s</code> <code>int \\| None</code> <code>None</code> Lease duration (seconds). <code>None</code> uses server default <code>servers</code> <code>list[tuple[str, int]]</code> <code>[(\"127.0.0.1\", 6388)]</code> Server addresses <code>sharding_strategy</code> <code>ShardingStrategy</code> <code>stable_hash_shard</code> Key-to-server mapping function <code>renew_ratio</code> <code>float</code> <code>0.5</code> Renew at <code>lease * ratio</code> seconds"},{"location":"client/async/#attributes","title":"Attributes","text":"<p>After acquiring a lock, these attributes are available:</p> Attribute Type Description <code>token</code> <code>str \\| None</code> The lock token (UUID hex). <code>None</code> if not held <code>lease</code> <code>int</code> Lease duration in seconds as reported by the server"},{"location":"client/async/#background-renewal","title":"Background renewal","text":"<p>Once a lock is acquired, the client starts an <code>asyncio.Task</code> that sends renew requests at <code>lease * renew_ratio</code> intervals. If renewal fails (server unreachable, lease already expired), the client logs an error and sets <code>token = None</code>.</p> <p>The renewal task is cancelled automatically on <code>release()</code>, context manager exit, or <code>aclose()</code>.</p>"},{"location":"client/async/#cleanup","title":"Cleanup","text":"<p>If you use manual <code>acquire()</code>, always call <code>release()</code> or <code>aclose()</code> to clean up the connection:</p> <pre><code>lock = DistributedLock(\"my-key\")\ntry:\n    if await lock.acquire():\n        # work\n        await lock.release()\nfinally:\n    await lock.aclose()\n</code></pre>"},{"location":"client/async/#low-level-functions","title":"Low-level functions","text":"<p>The module also exposes low-level protocol functions for direct use:</p> <pre><code>from dflockd.client import acquire, release, renew\n\nreader, writer = await asyncio.open_connection(\"127.0.0.1\", 6388)\n\ntoken, lease = await acquire(reader, writer, \"my-key\", timeout_s=10)\nremaining = await renew(reader, writer, \"my-key\", token)\nawait release(reader, writer, \"my-key\", token)\n\nwriter.close()\nawait writer.wait_closed()\n</code></pre>"},{"location":"client/sync/","title":"Sync Client","text":"<p>The sync client uses standard <code>socket</code> and <code>threading</code> for blocking lock operations with automatic background lease renewal. No asyncio required.</p> <pre><code>from dflockd.sync_client import DistributedLock\n</code></pre>"},{"location":"client/sync/#context-manager","title":"Context manager","text":"<p>The recommended way to use the client:</p> <pre><code>from dflockd.sync_client import DistributedLock\n\nwith DistributedLock(\"my-key\", acquire_timeout_s=10) as lock:\n    print(f\"token={lock.token} lease={lock.lease}\")\n    # critical section\n</code></pre> <p>If the lock cannot be acquired within the timeout, a <code>TimeoutError</code> is raised.</p>"},{"location":"client/sync/#manual-acquirerelease","title":"Manual acquire/release","text":"<pre><code>lock = DistributedLock(\"my-key\", acquire_timeout_s=10)\nif lock.acquire():\n    try:\n        # critical section\n        pass\n    finally:\n        lock.release()\n</code></pre> <p><code>acquire()</code> returns <code>False</code> on timeout instead of raising.</p>"},{"location":"client/sync/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>key</code> <code>str</code> (required) Lock name <code>acquire_timeout_s</code> <code>int</code> <code>10</code> Seconds to wait for acquisition <code>lease_ttl_s</code> <code>int \\| None</code> <code>None</code> Lease duration (seconds). <code>None</code> uses server default <code>servers</code> <code>list[tuple[str, int]]</code> <code>[(\"127.0.0.1\", 6388)]</code> Server addresses <code>sharding_strategy</code> <code>ShardingStrategy</code> <code>stable_hash_shard</code> Key-to-server mapping function <code>renew_ratio</code> <code>float</code> <code>0.5</code> Renew at <code>lease * ratio</code> seconds"},{"location":"client/sync/#attributes","title":"Attributes","text":"Attribute Type Description <code>token</code> <code>str \\| None</code> The lock token (UUID hex). <code>None</code> if not held <code>lease</code> <code>int</code> Lease duration in seconds as reported by the server"},{"location":"client/sync/#background-renewal","title":"Background renewal","text":"<p>Once acquired, a daemon thread sends renew requests at <code>lease * renew_ratio</code> intervals. If renewal fails, the client logs an error and sets <code>token = None</code>.</p> <p>The renewal thread is stopped automatically on <code>release()</code>, context manager exit, or <code>close()</code>.</p>"},{"location":"client/sync/#cleanup","title":"Cleanup","text":"<p>Always call <code>release()</code> or <code>close()</code> when using manual acquire:</p> <pre><code>lock = DistributedLock(\"my-key\")\ntry:\n    if lock.acquire():\n        # work\n        lock.release()\nfinally:\n    lock.close()\n</code></pre>"},{"location":"client/sync/#low-level-functions","title":"Low-level functions","text":"<p>Direct protocol functions are also available:</p> <pre><code>import socket\nfrom dflockd.sync_client import acquire, release, renew\n\nsock = socket.create_connection((\"127.0.0.1\", 6388))\nrfile = sock.makefile(\"r\", encoding=\"utf-8\")\n\ntoken, lease = acquire(sock, rfile, \"my-key\", acquire_timeout_s=10)\nremaining = renew(sock, rfile, \"my-key\", token)\nrelease(sock, rfile, \"my-key\", token)\n\nrfile.close()\nsock.close()\n</code></pre>"},{"location":"client/sync/#async-vs-sync","title":"Async vs sync","text":"Async Sync Import <code>dflockd.client</code> <code>dflockd.sync_client</code> Context manager <code>async with</code> <code>with</code> Renewal <code>asyncio.Task</code> <code>threading.Thread</code> (daemon) Cleanup <code>await lock.aclose()</code> <code>lock.close()</code> Best for asyncio applications, high concurrency Scripts, threads, simple applications"},{"location":"getting-started/examples/","title":"Examples","text":""},{"location":"getting-started/examples/#hold-a-lock-with-auto-renewal","title":"Hold a lock with auto-renewal","text":"<p>Acquire a lock, hold it for an extended period while the client automatically renews the lease in the background:</p> AsyncSync <pre><code>import asyncio\nfrom dflockd.client import DistributedLock\n\nasync def main():\n    async with DistributedLock(\"foo\", acquire_timeout_s=10, lease_ttl_s=20) as lock:\n        print(f\"acquired key={lock.key} token={lock.token} lease={lock.lease}\")\n        await asyncio.sleep(45)  # lease renews automatically\n        print(\"done critical section\")\n\nasyncio.run(main())\n</code></pre> <pre><code>import time\nfrom dflockd.sync_client import DistributedLock\n\nwith DistributedLock(\"foo\", acquire_timeout_s=10, lease_ttl_s=20) as lock:\n    print(f\"acquired key={lock.key} token={lock.token} lease={lock.lease}\")\n    time.sleep(45)  # lease renews automatically\n    print(\"done critical section\")\n</code></pre>"},{"location":"getting-started/examples/#fifo-lock-ordering","title":"FIFO lock ordering","text":"<p>Multiple workers competing for the same lock are granted access in FIFO order:</p> AsyncSync <pre><code>import asyncio\nfrom dflockd.client import DistributedLock\n\nasync def worker(worker_id: int):\n    async with DistributedLock(\"foo\", acquire_timeout_s=12) as lock:\n        print(f\"acquired  ({worker_id}): {lock.token}\")\n        await asyncio.sleep(1)\n        print(f\"released  ({worker_id}): {lock.token}\")\n\nasync def main():\n    tasks = [worker(i) for i in range(9)]\n    await asyncio.gather(*tasks)\n\nasyncio.run(main())\n</code></pre> <pre><code>import threading\nimport time\nfrom dflockd.sync_client import DistributedLock\n\ndef worker(worker_id: int):\n    with DistributedLock(\"foo\", acquire_timeout_s=30) as lock:\n        print(f\"acquired  ({worker_id}): {lock.token}\")\n        time.sleep(1)\n        print(f\"released  ({worker_id}): {lock.token}\")\n\nthreads = [threading.Thread(target=worker, args=(i,)) for i in range(9)]\nfor t in threads:\n    t.start()\nfor t in threads:\n    t.join()\n</code></pre>"},{"location":"getting-started/examples/#multi-server-sharding","title":"Multi-server sharding","text":"<p>Distribute keys across multiple dflockd instances. Each key deterministically routes to the same server:</p> <pre><code>from dflockd.sync_client import DistributedLock\n\nservers = [(\"server1\", 6388), (\"server2\", 6388), (\"server3\", 6388)]\n\nwith DistributedLock(\"my-key\", servers=servers) as lock:\n    print(f\"token={lock.token} lease={lock.lease}\")\n</code></pre>"},{"location":"getting-started/examples/#custom-sharding-strategy","title":"Custom sharding strategy","text":"<p>Override the default CRC-32 sharding with your own logic:</p> <pre><code>from dflockd.sync_client import DistributedLock\n\ndef my_strategy(key: str, num_servers: int) -&gt; int:\n    \"\"\"Route all keys to the first server.\"\"\"\n    return 0\n\nservers = [(\"server1\", 6388), (\"server2\", 6388)]\n\nwith DistributedLock(\"my-key\", servers=servers, sharding_strategy=my_strategy) as lock:\n    print(f\"token={lock.token}\")\n</code></pre>"},{"location":"getting-started/examples/#raw-tcp-protocol","title":"Raw TCP protocol","text":"<p>You can interact with dflockd from any language using its line-based TCP protocol:</p> <pre><code># Acquire a lock with 10s timeout\nprintf 'l\\nmy-key\\n10\\n' | nc localhost 6388\n# Response: ok &lt;token&gt; &lt;lease_ttl&gt;\n\n# Release (substitute your token)\nprintf 'r\\nmy-key\\n&lt;token&gt;\\n' | nc localhost 6388\n# Response: ok\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.13 or later</li> <li>No external dependencies</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"pipuv <pre><code>pip install dflockd\n</code></pre> <pre><code>uv add dflockd\n</code></pre>"},{"location":"getting-started/installation/#install-from-source","title":"Install from source","text":"<pre><code>git clone https://github.com/mtingers/dflockd.git\ncd dflockd\nuv sync\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify installation","text":"<p>Start the server to confirm everything is working:</p> <pre><code># If installed from PyPI\ndflockd\n\n# If installed from source\nuv run dflockd\n</code></pre> <p>You should see log output indicating the server is listening:</p> <pre><code>INFO dflockd: listening on ('0.0.0.0', 6388)\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":""},{"location":"getting-started/quickstart/#1-start-the-server","title":"1. Start the server","text":"<pre><code>dflockd\n</code></pre> <p>The server listens on <code>0.0.0.0:6388</code> by default. See Server Configuration for tuning options.</p>"},{"location":"getting-started/quickstart/#2-acquire-a-lock","title":"2. Acquire a lock","text":""},{"location":"getting-started/quickstart/#async-client","title":"Async client","text":"<pre><code>import asyncio\nfrom dflockd.client import DistributedLock\n\nasync def main():\n    async with DistributedLock(\"my-key\", acquire_timeout_s=10) as lock:\n        print(f\"token={lock.token} lease={lock.lease}\")\n        # critical section \u2014 lease auto-renews in background\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#sync-client","title":"Sync client","text":"<pre><code>from dflockd.sync_client import DistributedLock\n\nwith DistributedLock(\"my-key\", acquire_timeout_s=10) as lock:\n    print(f\"token={lock.token} lease={lock.lease}\")\n    # critical section \u2014 lease auto-renews in background thread\n</code></pre>"},{"location":"getting-started/quickstart/#3-manual-acquirerelease","title":"3. Manual acquire/release","text":"<p>Both clients support explicit <code>acquire()</code> / <code>release()</code> outside of a context manager:</p> <pre><code>from dflockd.sync_client import DistributedLock\n\nlock = DistributedLock(\"my-key\")\nif lock.acquire():\n    try:\n        pass  # critical section\n    finally:\n        lock.release()\n</code></pre>"},{"location":"getting-started/quickstart/#what-happens-under-the-hood","title":"What happens under the hood","text":"<ol> <li>The client opens a TCP connection to the server (selected via sharding if multiple servers are configured).</li> <li>It sends a lock request with the key and timeout.</li> <li>The server grants the lock immediately if it's free, or enqueues the client in FIFO order.</li> <li>Once acquired, the client starts a background task/thread that renews the lease at <code>lease * renew_ratio</code> intervals.</li> <li>On context manager exit (or explicit <code>release()</code>), the client sends a release command and closes the connection.</li> <li>If the client disconnects without releasing, the server cleans up automatically.</li> </ol>"},{"location":"guide/architecture/","title":"Architecture","text":""},{"location":"guide/architecture/#overview","title":"Overview","text":"<p>dflockd is a single-process asyncio server that manages named locks with FIFO ordering, automatic lease expiry, and garbage collection of idle state.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    TCP     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Client   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502            dflockd server           \u2502\n\u2502  (async   \u2502  line-    \u2502                                     \u2502\n\u2502   or sync)\u2502  based    \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  UTF-8     \u2502  \u2502  Lock     \u2502  \u2502  Background    \u2502  \u2502\n                        \u2502  \u2502  State    \u2502  \u2502  Tasks         \u2502  \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502  \u2502          \u2502  \u2502                \u2502  \u2502\n\u2502  Client   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502  \u2502  key \u2192   \u2502  \u2502  \u2022 lease       \u2502  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502  \u2502   owner  \u2502  \u2502    expiry      \u2502  \u2502\n                        \u2502  \u2502   waiter \u2502  \u2502  \u2022 lock GC     \u2502  \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502  \u2502   queue  \u2502  \u2502                \u2502  \u2502\n\u2502  Client   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"guide/architecture/#lock-state","title":"Lock state","text":"<p>Each named lock key maintains a <code>LockState</code>:</p> <ul> <li>owner_token \u2014 the UUID token of the current holder (or <code>None</code> if free)</li> <li>owner_conn_id \u2014 connection ID of the current holder</li> <li>lease_expires_at \u2014 monotonic timestamp when the lease expires</li> <li>waiters \u2014 FIFO deque of pending acquire requests</li> <li>last_activity \u2014 timestamp of the most recent operation (used for GC)</li> </ul>"},{"location":"guide/architecture/#fifo-acquire-flow","title":"FIFO acquire flow","text":"<ol> <li>A client sends a lock request for key <code>K</code> with timeout <code>T</code> and optional lease TTL.</li> <li>If <code>K</code> is free and has no waiters, the lock is granted immediately (fast path).</li> <li>Otherwise, the client is appended to the waiter deque and blocks until:<ul> <li>The lock is granted (previous holder released or lease expired), or</li> <li>The timeout <code>T</code> elapses (client receives <code>timeout</code>).</li> </ul> </li> <li>When a lock is released or expires, the next waiter in FIFO order is granted the lock.</li> </ol>"},{"location":"guide/architecture/#background-tasks","title":"Background tasks","text":""},{"location":"guide/architecture/#lease-expiry-loop","title":"Lease expiry loop","text":"<p>Runs every <code>LEASE_SWEEP_INTERVAL_S</code> seconds (default: 1s). For each held lock:</p> <ul> <li>If <code>now &gt;= lease_expires_at</code>, the owner is evicted and the lock passes to the next FIFO waiter.</li> <li>This prevents deadlocks from crashed or hung clients.</li> </ul>"},{"location":"guide/architecture/#lock-garbage-collection","title":"Lock garbage collection","text":"<p>Runs every <code>GC_LOOP_SLEEP</code> seconds (default: 5s). Prunes lock state entries where:</p> <ul> <li>No owner is holding the lock</li> <li>No waiters are queued</li> <li>The key has been idle longer than <code>GC_MAX_UNUSED_TIME</code> (default: 60s)</li> </ul> <p>This prevents unbounded memory growth from transient keys.</p>"},{"location":"guide/architecture/#connection-cleanup","title":"Connection cleanup","text":"<p>When a TCP connection closes (graceful or abrupt), the server:</p> <ol> <li>Cancels any pending waiter futures belonging to that connection.</li> <li>Releases any locks held by that connection.</li> <li>Transfers released locks to the next FIFO waiter, if any.</li> </ol>"},{"location":"guide/architecture/#concurrency-model","title":"Concurrency model","text":"<p>All lock state mutations are serialized through a single <code>asyncio.Lock</code> (<code>tracking_lock</code>). This ensures consistency without complex fine-grained locking, while asyncio's cooperative scheduling keeps throughput high for the I/O-bound workload.</p>"},{"location":"guide/sharding/","title":"Sharding","text":""},{"location":"guide/sharding/#overview","title":"Overview","text":"<p>When running multiple dflockd instances, the client distributes keys across servers using a sharding strategy. Each key deterministically routes to the same server, ensuring all operations on a given key go to the same instance.</p>"},{"location":"guide/sharding/#default-strategy","title":"Default strategy","text":"<p>The built-in <code>stable_hash_shard</code> uses <code>zlib.crc32</code> for deterministic hashing:</p> <pre><code>def stable_hash_shard(key: str, num_servers: int) -&gt; int:\n    return zlib.crc32(key.encode(\"utf-8\")) % num_servers\n</code></pre> <p>Unlike Python's built-in <code>hash()</code>, CRC-32 produces the same result across processes regardless of <code>PYTHONHASHSEED</code>, making it safe for distributed use.</p>"},{"location":"guide/sharding/#multi-server-setup","title":"Multi-server setup","text":"<p>Pass a list of <code>(host, port)</code> tuples to the client:</p> <pre><code>from dflockd.sync_client import DistributedLock\n\nservers = [\n    (\"lock-server-1\", 6388),\n    (\"lock-server-2\", 6388),\n    (\"lock-server-3\", 6388),\n]\n\nwith DistributedLock(\"my-key\", servers=servers) as lock:\n    # \"my-key\" always routes to the same server\n    pass\n</code></pre>"},{"location":"guide/sharding/#custom-strategies","title":"Custom strategies","text":"<p>Provide any callable with the signature <code>(key: str, num_servers: int) -&gt; int</code>:</p> <pre><code>from dflockd.sync_client import DistributedLock\n\ndef region_shard(key: str, num_servers: int) -&gt; int:\n    \"\"\"Route keys prefixed with 'eu-' to server 0, everything else hashed.\"\"\"\n    if key.startswith(\"eu-\"):\n        return 0\n    import zlib\n    return zlib.crc32(key.encode()) % num_servers\n\nservers = [(\"eu-server\", 6388), (\"us-server-1\", 6388), (\"us-server-2\", 6388)]\n\nwith DistributedLock(\"eu-job-1\", servers=servers, sharding_strategy=region_shard) as lock:\n    pass  # routes to eu-server\n</code></pre>"},{"location":"guide/sharding/#type-signature","title":"Type signature","text":"<pre><code>from collections.abc import Callable\n\nShardingStrategy = Callable[[str, int], int]\n</code></pre> <p>The function receives the lock key and the number of servers, and must return a server index in <code>[0, num_servers)</code>.</p> <p>Note</p> <p>Each dflockd instance is independent \u2014 there is no replication or consensus between servers. If a server goes down, locks assigned to that server become unavailable. For high availability, consider running behind a load balancer with health checks or using a consensus-based system.</p>"},{"location":"server/configuration/","title":"Server Configuration","text":""},{"location":"server/configuration/#running-the-server","title":"Running the server","text":"<pre><code># Default: listens on 0.0.0.0:6388\ndflockd\n\n# Custom port\ndflockd --port 7000\n\n# Multiple options\ndflockd --host 127.0.0.1 --port 7000 --max-locks 512\n</code></pre>"},{"location":"server/configuration/#cli-flags","title":"CLI flags","text":"Flag Default Description <code>--host</code> <code>0.0.0.0</code> Bind address <code>--port</code> <code>6388</code> Bind port <code>--default-lease-ttl</code> <code>33</code> Default lock lease duration (seconds) <code>--lease-sweep-interval</code> <code>1</code> How often to check for expired leases (seconds) <code>--gc-interval</code> <code>5</code> How often to prune idle lock state (seconds) <code>--gc-max-idle</code> <code>60</code> Seconds before idle lock state is pruned <code>--max-locks</code> <code>1024</code> Maximum number of unique lock keys <code>--read-timeout</code> <code>23</code> Client read timeout (seconds)"},{"location":"server/configuration/#environment-variables","title":"Environment variables","text":"<p>All settings can be configured via environment variables. Environment variables take precedence over CLI flags.</p> Variable Default Description <code>DFLOCKD_HOST</code> <code>0.0.0.0</code> Bind address <code>DFLOCKD_PORT</code> <code>6388</code> Bind port <code>DFLOCKD_DEFAULT_LEASE_TTL_S</code> <code>33</code> Default lock lease duration (seconds) <code>DFLOCKD_LEASE_SWEEP_INTERVAL_S</code> <code>1</code> How often to check for expired leases <code>DFLOCKD_GC_LOOP_SLEEP</code> <code>5</code> How often to prune idle lock state <code>DFLOCKD_GC_MAX_UNUSED_TIME</code> <code>60</code> Seconds before idle lock state is pruned <code>DFLOCKD_MAX_LOCKS</code> <code>1024</code> Maximum number of unique lock keys <code>DFLOCKD_READ_TIMEOUT_S</code> <code>23</code> Client read timeout (seconds) <pre><code># Example: configure via environment\nexport DFLOCKD_PORT=7000\nexport DFLOCKD_MAX_LOCKS=2048\ndflockd\n</code></pre>"},{"location":"server/configuration/#tuning-guide","title":"Tuning guide","text":""},{"location":"server/configuration/#lease-ttl","title":"Lease TTL","text":"<p>The <code>default-lease-ttl</code> controls how long a lock is held before it expires if not renewed. Clients automatically renew at <code>lease * renew_ratio</code> (default 0.5), so a 33-second TTL renews every ~16 seconds.</p> <ul> <li>Shorter TTL (e.g. 10s): faster failover when clients crash, but more renewal traffic.</li> <li>Longer TTL (e.g. 60s): less renewal traffic, but slower failover.</li> </ul>"},{"location":"server/configuration/#max-locks","title":"Max locks","text":"<p>The <code>max-locks</code> setting caps the number of unique lock keys tracked by the server. When the limit is reached, new lock requests for unknown keys return <code>error_max_locks</code>. Existing keys are unaffected.</p>"},{"location":"server/configuration/#garbage-collection","title":"Garbage collection","text":"<p>Idle lock state (no owner, no waiters) is pruned after <code>gc-max-idle</code> seconds. The GC runs every <code>gc-interval</code> seconds. For workloads with many transient keys, lower <code>gc-max-idle</code> to reclaim memory faster.</p>"},{"location":"server/configuration/#read-timeout","title":"Read timeout","text":"<p>The <code>read-timeout</code> controls how long the server waits for a client to send a complete request line. Idle connections that send no data within this window are disconnected. This prevents resource exhaustion from abandoned connections.</p>"}]}